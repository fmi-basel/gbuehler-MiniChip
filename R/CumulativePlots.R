#' @title CumulativePlots
#'
#' @description Summarizes and plots the values for counts around positions of interest in the genome.
#'
#' @details This function plots summarized (default = mean) values of pre-calculated read counts around the positions of interest in the genome, for example summits of ChIP peaks.
#'
#' @param counts A list of counts across peak summits generated by SummitHeatmap.
#' @param bamNames Character vector containing the names to describe the \code{bamFiles} you are using (for example: "H3K9me3_reads"). 
#' If no names are supplied, the names of the \code{counts} list are used.
#' @param span The distance from the peak summit to the left and right that you want your heatmap to extand to. Default is 2025.
#' @param step The window size in which reads are counted/plotted in the heatmap. Default is 50.
#' @param summarizing The function to summarize the heatmaps across peaks to achieve a cumulative line. Default is "mean".
#' @param overlapNames A character vector of the row names of the counts that overlap with a given annotation, for example, transcription start sites.
#' @param confInterval The confidence interval around the mean that will be calculated and plotted. Default is .95. Only used if summarizing = "mean".
#' @param plot If TRUE (default), returns the cumulative plots, otherwise returns the underlying data table.
#' @param plotcols Two different colors for the lines that contain the values for the peaks defined in overlapNames, and the rest of the peaks.
#' @param overlapLabels Two different labels for the lines that contain the values for the peaks defined in overlapNames, and the rest of the peaks.
#'
#' @return Returns a matrix with mean values of the log2 of supplied counts (with pseudocount of 1 added) in each bin for each sample, split by overlap_names.
#' Plots of mean values for read counts around position of interest in the genome.
#' One plot for each count matrix supplied. All plots are arranged on one page and saved as a png.
#'
#' @importFrom reshape2 melt
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 geom_line
#' @importFrom ggplot2 geom_smooth
#' @importFrom ggplot2 facet_wrap
#' @importFrom ggplot2 scale_fill_manual
#' @importFrom ggplot2 scale_color_manual
#' @importFrom ggplot2 theme_classic
#' @importFrom ggplot2 aes vars ylab
#' @importFrom tidyr pivot_longer
#' @importFrom tidyr %>%
#' @importFrom tidyselect contains
#' @importFrom stats sd
#' @importFrom stats qt
#' @importFrom rlang .data
#'
#' @examples
#' counts <- list(matrix(rnorm(21000,2,1),ncol=81,nrow=100,dimnames=list(1:100,-40:40)),
#'                matrix(rnorm(21000,2,1),ncol=81,nrow=100,dimnames=list(1:100,-40:40)))
#' bamNames <- c("counts1","counts2")
#' names(counts) <- bamNames
#' CumulativePlots(counts,bamNames=bamNames,overlapNames="NA")
#'
#' @export
CumulativePlots <- function(counts,bamNames=names(counts),span=2025,step=50,summarizing = "mean", overlapNames="NA", plot=TRUE, confInterval= .95,
                            plotcols = c("violet","darkgrey"), overlapLabels = c("overlap", "no overlap")){
  
  nwindows <- ceiling((span*2)/step)
  if(nwindows %% 2 == 0){
    nwindows <- nwindows + 1
  }
  
  regionwidth <- step * nwindows
  windows <- seq(from=0,to=regionwidth-step,by=step)
  binmids <- windows - regionwidth/2 + step/2
  
  avg.counts <- lapply(1:length(bamNames), matrix,  nrow=0, ncol=0)

  if (summarizing == "mean"){
    for (bam.sample in seq_along(bamNames)){
      mycounts <- log2(counts[[bam.sample]]+1)
      mycounts1 <- mycounts[row.names(mycounts) %in% overlapNames,]
      mycounts2 <- mycounts[row.names(mycounts) %in% overlapNames == FALSE,]

      #claculate the mean, and the standard error for each binmids position across all peaks
      avg.cts <- data.frame(mean_overlap1=apply(mycounts1,2,mean),
                            mean_overlap2=apply(mycounts2,2,mean),
                            se_overlap1 = apply(mycounts1,2,sd)/sqrt(nrow(mycounts1)),
                            se_overlap2 = apply(mycounts2,2,sd)/sqrt(nrow(mycounts2)),
                            position=binmids, name=bamNames[bam.sample])

       #claculate the confidence intervals for each binmids position across all peaks
      #reference: http://www.cookbook-r.com/Manipulating_data/Summarizing_data/
      # Confidence interval multiplier for standard error
      # Calculate t-statistic for confidence interval:
      # e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
      ciMult1 <- qt(confInterval/2 + .5, nrow(mycounts1)-1)
      ciMult2 <- qt(confInterval/2 + .5, nrow(mycounts2)-1)

      avg.cts$ci.upper_overlap1 <- avg.cts$mean_overlap1 + avg.cts$se_overlap1 * ciMult1
      avg.cts$ci.lower_overlap1 <- avg.cts$mean_overlap1 - avg.cts$se_overlap1 * ciMult1

      avg.cts$ci.upper_overlap2 <- avg.cts$mean_overlap2 + avg.cts$se_overlap2 * ciMult2
      avg.cts$ci.lower_overlap2 <- avg.cts$mean_overlap2 - avg.cts$se_overlap2 * ciMult2

      #add the data frame into the list of data frames for each bam sample
      avg.counts[[bam.sample]] <- avg.cts
    }
    #collapse the list into one long data frame with a column indication the bam sample name
    avg.counts <- do.call("rbind",avg.counts)

    if(plot==TRUE){
      mean.plots.long <- avg.counts %>% pivot_longer(contains("overlap"),names_to = c(".value","overlap"),names_sep="_")
      p <- ggplot(mean.plots.long,aes(x=.data$position,y=.data$mean)) + geom_smooth(aes(ymin=.data$ci.lower,ymax=.data$ci.upper,fill=.data$overlap,color=.data$overlap),stat="identity")
      p <- p + facet_wrap(vars(.data$name),scales="free") + ylab("log2(cpm)") + theme_classic()
      p <- p + scale_fill_manual(values=plotcols,labels = overlapLabels)
      p <- p + scale_color_manual(values=plotcols,labels = overlapLabels)
      return(p)
    } else {
      return(avg.counts)
    }

  } else {

    for (bam.sample in seq_along(bamNames)){
      mycounts <- log2(counts[[bam.sample]]+1)
      mycounts1 <- mycounts[row.names(mycounts) %in% overlapNames,]
      mycounts2 <- mycounts[row.names(mycounts) %in% overlapNames == FALSE,]

      avg.cts <- data.frame(overlap.mean=apply(mycounts1,2,summarizing),
                            no.overlap.mean=apply(mycounts2,2,summarizing),
                            position=binmids, name=bamNames[bam.sample])
      #add the data frame into the list of data frames for each bam sample
      avg.counts[[bam.sample]] <- avg.cts
    }
    #collapse the list into one long data frame with a column indication the bam sample name

    avg.counts <- do.call("rbind",avg.counts)

  if(plot==TRUE){
    avg.counts.long <- melt(avg.counts,id.vars=c("name","position"))
    p <- ggplot(avg.counts.long,aes(x=.data$position, y=.data$value)) + geom_line(aes(color=.data$variable)) + facet_wrap(vars(.data$name),scales="free")
    p <- p + theme_classic() + ylab("log2(cpm)") + scale_color_manual(values=plotcols,labels = overlapLabels)
    return(p)
  } else {
  return(avg.counts)
  }
  }
}
