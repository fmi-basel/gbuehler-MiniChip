#' @title DrawSummitHeatmaps
#'
#' @description This function plots heatmaps of pre-calculated read counts around the summits of ChIP peaks.
#'
#' @details This function plots heatmaps of pre-calculated read counts around the summits of ChIP peaks.
#'
#' @param counts A list of counts across peak summits generated by SummitHeatmap.
#' @param bamNames A character vector of names to describe the bam files you are using. This should match colnames(counts).
#' @param plotcols The colors for the topCpm value for the heatmaps. Default is darkblue for all hetmaps.
#' Should be a vector of colors of the same length as the number of heatmaps drawn.
#' @param topCpm The CPM values that correspond to the black color Any value above that will appear black.
#' Should be a vector of integers of the same length as the number of heatmaps drawn. If not secified, maximum CPM value in the current count table is used.
#' @param medianCpm The CPM values that correspond to the plotcols. Any value above that will get darker, towrads black.
#' Should be a vector of integers of the same length as the number of heatmaps drawn. If not secified, median CPM value in the current count table is used.
#' @param bottomCpm The CPM values that correspond to the white color. Any value below that will appear white.
#' Should be a vector of integers of the same length as the number of heatmaps drawn. If not secified, minimum CPM value in the current count table is used.
#' @param nicebamNames A character vector of short names to describe the bam files you are using. Needs to be the same length as bamNames.
#' @param orderSample The heatmap where the rows will be ordered by the 0 bin. Defaults to 0 (no ordering).
#' @param orderWindows The heatmap windows that will be used for ordering. By default, the heatmap will be ordered by the mean of all windows.
#' If an integer (n) is supplied, it will be ordered by the middle window plus n windows on each side.
#' @param clusterSample The heatmap where the rows will be ordered by hierarchical clustering. Defaults to 1 (the first heatmap).
#' @param summarizing The function to average the heatmaps to achieve a cumulative line. The cpm or count values are first log2 transformed
#'  with a pseudo count of 1 added. Default is mean.
#' @param show_axis Show the axis of the cumulative plot above the heatmap. Default is FALSE.
#' @param use.log If TRUE, the heatmap will be plotted in log2 scale. FALSE by default. A pseudo-count of 1 is added if Zeros are encountered in the matrix.
#' @param splitHM Optinal. You can add a list of row identifiers of the counts table(s) that have a certain attribute.
#' The heatmap will be split into the rows that are in this list and the remianing rows.
#' @param split_pos Name for the part of the split heatmap that overlaps the splitHM rows. Default is "yes".
#' @param split_neg Name for the part of the split heatmap that does not overlap the splitHM rows. Default is "no".
#' @param TargetHeight The number of rows the plotted heatmap should have after averaging. Default = 0, which means no summarization will be done. If TargetHeight > 0,
#' the number of rows in the final heatmap will be reduced and therefore splitHM cannot be used.
#' @param MetaScale A vector of the same length as heatmaps, with values "all" or "individual". Defaults to "all",
#' which means that the maximum of the y-axis for the metaplots will correspond to the maximum of all values in all heatmaps.
#' Otherwise the scale will correspond to the maximum of the current metaplot.
#'
#' @return A complex heatmap object containing a heatmap for each sample (each bam file),
#' sorted by the values in the middle window (around peak summit) of the chosen orderSample.
#'
#' @importFrom ComplexHeatmap Heatmap
#' @importFrom ComplexHeatmap HeatmapAnnotation
#' @importFrom ComplexHeatmap anno_text
#' @importFrom ComplexHeatmap max_text_width
#' @importFrom ComplexHeatmap anno_lines
#' @importFrom grid gpar
#' @importFrom grid unit
#' @importFrom grid pushViewport
#' @importFrom grid grid.rect
#' @importFrom grid grid.points
#' @importFrom grid grid.lines
#' @importFrom grid upViewport
#' @importFrom circlize colorRamp2
#' @importFrom stats dist
#' @importFrom stats hclust
#'
#' @examples
#' library(methods)
#' counts <- list(matrix(abs(rnorm(21000,2,1)),ncol=21,nrow=100,dimnames=list(1:100,-10:10)),
#'                matrix(abs(rnorm(21000,2,1)),ncol=21,nrow=100,dimnames=list(1:100,-10:10)))
#' bamNames <- c("counts1","counts2")
#' names(counts) <- bamNames
#' DrawSummitHeatmaps(counts,bamNames, orderSample=1, bottomCpm = c(0,0), topCpm=c(10,10),use.log=FALSE)
#'
#' @export
DrawSummitHeatmaps <- function(counts, bamNames, nicebamNames = bamNames, plotcols= rep("darkblue",length(bamNames)),use.log = FALSE,
                               topCpm, medianCpm, bottomCpm, splitHM, split_pos = "yes", split_neg = "no",TargetHeight = 0,
                               orderSample = 0, orderWindows=NULL, clusterSample = 1, summarizing = "mean",show_axis=FALSE,
                               MetaScale=rep("all",length(bamNames))){

#select ordering by middle window or clustering approach
if(orderSample > 0){
  counts1 <- (counts[[bamNames[orderSample]]])
  if (missing(orderWindows)){
    #sort by mean of all values
    counts.sorted <- counts1[order(rowMeans(counts1)),]
  } else {
  #sort by value at point 0 + n windows on each side
  zero.inx <- which(colnames(counts1) == 0)
  zero5.inx <- seq(zero.inx-orderWindows,zero.inx+orderWindows,1)
  counts.sorted <- counts1[order(rowMeans(counts1[,zero5.inx])),]
  }
  counts.sorted.rev <- apply(counts.sorted,2,rev)
  } else {
  counts1 <- (counts[[bamNames[clusterSample]]])
  dist_mat <- dist(counts1, method = 'euclidean')
  hclust_avg <- hclust(dist_mat, method = 'average')
  }

#initialize empty heatmap list
ht_list = NULL
#generate bottom annotation with binnames
if(max(abs(as.numeric(colnames(counts1)))) > 1000){
binnames <- ifelse((as.numeric(colnames(counts1))/1000)%%1==0,colnames(counts1),"")
} else {
binnames <- ifelse((as.numeric(colnames(counts1))/100)%%1==0,colnames(counts1),"")
}
bin_anno <- HeatmapAnnotation(text = anno_text(binnames, rot = 45, location = unit(1, "npc"), just = "right",gp=gpar(fontsize=8,fontface = "italic")),
                              annotation_height = max_text_width(binnames))

#take log2 of all counts tables (adding a pseudocount of 1 if 0s are present in the table)
all.counts.log <- lapply(counts,Log2Transform,pseudocount =1)

#summarize the counts per bin for the cumulative plot
all.counts.median <- lapply(all.counts.log, function(x) apply(x,2,summarizing))
all.counts.max <- max(unlist(all.counts.median))

#loop over all samples
for (bam.sample in seq_along(bamNames)){

  #select counts table for current sample
  counts.median <- (all.counts.median[[bamNames[bam.sample]]])

  #select the y-axis limits of the metaplots:
  #a) maximum is the maximum of all counts tables,
  #b) maximum is the maximum of each counts table
  if (MetaScale[bam.sample] == "all"){
    anno.lims <- c(0,all.counts.max)
  } else {
    anno.lims <- c(0,max(0.1,max(counts.median)))
}
  #generate cumulative plot as heatmap annotation
  cumulative_anno <- HeatmapAnnotation(x=anno_lines(counts.median,size=unit(1, "mm"),axis=show_axis,smooth=FALSE,
                                 border=FALSE, ylim=anno.lims,
                                 gp=gpar(lwd=2,col=plotcols[bam.sample])),show_annotation_name=FALSE)

  #select log transformed or original count values based on use.log option
  if(use.log == TRUE){
    counts3 <- (all.counts.log[[bamNames[bam.sample]]])
  } else {
    counts3 <- (counts[[bamNames[bam.sample]]])
  }

  #generate plotting color cutoffs based on cutoffs provided or min,median,max
  if (missing(bottomCpm)){
    BottomCpm <- min(counts3)
  } else {
    BottomCpm <- bottomCpm[bam.sample]
  }
  if (missing(medianCpm)){
    MedianCpm <- median(counts3)
  } else {
    MedianCpm <- medianCpm[bam.sample]
  }
  if (missing(topCpm)){
    TopCpm <- max(counts3)
  } else {
    TopCpm <- topCpm[bam.sample]
  }

  if(BottomCpm == TopCpm){
    sprintf("bottomCpm = topCpm for sample %s : please provide different values",bamNames[bam.sample])
    next
  } else {
  plotcolor <- circlize::colorRamp2(c(BottomCpm, MedianCpm, TopCpm), c("white", plotcols[bam.sample],"black"))
}

#decide if bin 0 value ordering or clustering is used
  if(orderSample > 0){

    #order the rows of the current counts table by the middle-value-sorted sample counts table
    counts.sorted <- counts3[row.names(counts.sorted.rev),]

    if (TargetHeight > 0){
    #summarize the rows to make the heatmap look smoother
    counts.sorted <- redim_matrix(counts.sorted, target_height = TargetHeight, target_width = ncol(counts.sorted))
    }

    #split the heatmap into 2 parts (only works if the counts.sorted table was not summarized)
    if(missing(splitHM)){
      row_split = NULL
    } else {
      row_split = ifelse(row.names(counts.sorted) %in% splitHM,split_pos,split_neg)
    }

#generate the heatmap list entry for the current sample (sorted by the middle values of the specified sample (orderSample option)) and append to complete heatmap list
  ht_list <- ht_list + Heatmap(counts.sorted,name = bamNames[bam.sample], cluster_rows = FALSE, cluster_columns = FALSE,
                               column_order = colnames(counts.sorted), col = plotcolor,
                               column_title = nicebamNames[bam.sample], column_title_gp = gpar(fontsize = 10, fontface = "bold"),
                               show_row_names = FALSE, show_column_names = FALSE,
                               bottom_annotation = bin_anno,
                               top_annotation = cumulative_anno,
                               use_raster = TRUE, raster_device = "CairoPNG",raster_quality=1,
                               #use_raster = TRUE, raster_device = "png",raster_quality=1,
                               row_split = row_split
   )
  } else {

    #split the heatmap into 2 parts
    if(missing(splitHM)){
      row_split = NULL
    } else {
      row_split = ifelse(row.names(counts3) %in% splitHM,split_pos,split_neg)
    }

    #generate the heatmap list entry for the current sample (sorted by the clustering of the specified sample (clusterSample option)) and append to complete heatmap list
    ht_list <- ht_list + Heatmap(counts3,name = bamNames[bam.sample], cluster_rows = hclust_avg, cluster_columns = FALSE,
                                 column_order = colnames(counts3), col = plotcolor,
                                 column_title = nicebamNames[bam.sample], column_title_gp = gpar(fontsize = 10, fontface = "bold"),
                                 show_row_names = FALSE, show_column_names = FALSE,
                                 bottom_annotation = bin_anno,
                                 top_annotation = cumulative_anno,
                                 use_raster = TRUE, raster_device = "CairoPNG",raster_quality=1,
                                # use_raster = UseRaster, raster_device = "png",raster_quality=1,
                                 row_split = row_split, show_row_dend = FALSE,show_column_dend = FALSE,
    )
  }}
return(ht_list)
}
