#' @title DrawSummitHeatmaps
#'
#' @description Plots heatmaps of pre-calculated read counts around the centers of provided regions of interest.
#'
#' @details Plots heatmaps of pre-calculated read counts around the centers of provided regions of interest, for example of ChIP peaks.
#' If multiple heatmap count tables a re supplied as a named list, it clusters or sorts the rows of a chosen heatmap based on its count values 
#' and keeps the rows of all otehr heatmaps in the same order. 
#'
#' @param counts A named list of read counts across (peak) region centers, preferentially generated by \code{SummitHeatmap} for compatibility.
#' @param bamNames Character vector containing the names to describe the samples in \code{counts} (for example: "H3K9me3"). 
#' If no names are supplied, the names of the list provided in \code{counts} are used.
#' @param plotcols Character vector of colors of the same length as the number of heatmaps drawn, corresponding to the colors for the medianCpm 
#' value for the heatmaps. Default is darkblue for all heatmaps.
#' @param topCpm Numeric vector of the same length as the number of heatmaps drawn, indicating the CPM values that correspond to the black color. Any value above that will appear black.
#' If not specified, maximum CPM value in the current count table is used.
#' @param medianCpm Numeric vector of the same length as the number of heatmaps drawn, indicating the CPM values that correspond to the \code{plotcols}. 
#' Any value above that will appear darker, any value below that will appear more white. If not specified, the median CPM value in the current count table is used.
#' @param bottomCpm Numeric vector of the same length as the number of heatmaps drawn, indicating the CPM values that correspond to the white color. 
#' Any value below that will appear white. If not specified, the minimum CPM value in the current count table is used.
#' @param orderSample Integer scalar giving the index of the heatmap whose values the rows of all heatmaps will be ordered by. 
#' Defaults to 1 (the first heatmap). If set to 0, the \code{clusterSample} heatmap will clustered by hierarchical clustering instead of ordered.
#' @param orderWindows The heatmap windows that will be used for ordering. By default, the heatmap will be ordered by the mean of all windows.
#' If an integer scalar is supplied, it will be ordered by the middle window plus n windows on each side.
#' @param clusterSample Integer scalar giving the index of the heatmap whose values the rows of all heatmaps will be ordered by hierarchical clustering. Defaults to 1 (the first heatmap).
#' @param summarizing The function to average the heatmaps to generate the metaplot. The cpm or count values are first log2 transformed
#'  (with a pseudo count of 1 added, if necessary). Default is mean.
#' @param show_axis Show the axis of the cumulative plot above the heatmap. Default is FALSE.
#' @param use.log Logical scalar indicating wether the heatmap will be plotted in log2 scale. FALSE by default. A pseudo-count of 1 is added if Zeros are encountered in the matrix.
#' @param splitHM Character vector of row identifiers of the counts table(s) that have a certain attribute.
#' The heatmap will be split into the rows that are in this vector and the remaining rows.
#' @param split_pos Character scalar giving the name for the part of the split heatmap that overlaps the splitHM rows. Default is "yes".
#' @param split_neg Character scalar giving the name for the part of the split heatmap that does not overlap the splitHM rows. Default is "no".
#' @param TargetHeight Integer scalar giving the number of rows the plotted heatmap should have after averaging. Default = 0, which means no summarization will be done. If TargetHeight > 0,
#' the number of rows in the final heatmap will be reduced and therefore splitHM cannot be used.
#' @param MetaScale A character vector of the same length as heatmaps, with values "all" or "individual". Defaults to "all",
#' which means that the maximum of the y-axis for the metaplots will correspond to the maximum of all values in all heatmaps.
#' Otherwise the scale will correspond to the maximum of the current metaplot.
#'
#' @return A complex heatmap object containing a heatmap for each sample provided in \code{counts},
#' sorted by the values in the middle window (around peak summit) of the chosen \code{orderSample}.
#'
#' @importFrom ComplexHeatmap Heatmap
#' @importFrom ComplexHeatmap HeatmapAnnotation
#' @importFrom ComplexHeatmap anno_text
#' @importFrom ComplexHeatmap max_text_width
#' @importFrom ComplexHeatmap anno_lines
#' @importFrom grid gpar
#' @importFrom grid unit
#' @importFrom grid pushViewport
#' @importFrom grid grid.rect
#' @importFrom grid grid.points
#' @importFrom grid grid.lines
#' @importFrom grid upViewport
#' @importFrom circlize colorRamp2
#' @importFrom stats dist
#' @importFrom stats hclust
#'
#' @examples
#' library(methods)
#' counts <- list(matrix(abs(rnorm(21000,2,1)),ncol=21,nrow=100,dimnames=list(1:100,-10:10)),
#'                matrix(abs(rnorm(21000,2,1)),ncol=21,nrow=100,dimnames=list(1:100,-10:10)))
 #' names(counts) <- c("counts1","counts2")
#' DrawSummitHeatmaps(counts, orderSample=1, bottomCpm = c(0,0), topCpm=c(10,10),use.log=FALSE)
#'
#' @export
DrawSummitHeatmaps <- function(counts, bamNames=names(counts), plotcols= rep("darkblue",length(bamNames)),use.log = FALSE,
                               topCpm, medianCpm, bottomCpm, splitHM, split_pos = "yes", split_neg = "no",TargetHeight = 0,
                               orderSample = 1, orderWindows=NULL, clusterSample = 1, summarizing = "mean",show_axis=FALSE,
                               MetaScale=rep("all",length(bamNames))){

#select ordering by middle window or clustering approach
if(orderSample > 0){
  counts1 <- (counts[[bamNames[orderSample]]])
  if (missing(orderWindows)){
    #sort by mean of all values
    counts.sorted <- counts1[order(rowMeans(counts1)),]
  } else {
  #sort by value at point 0 + n windows on each side
  zero.inx <- which(colnames(counts1) == 0)
  zero5.inx <- seq(zero.inx-orderWindows,zero.inx+orderWindows,1)
  counts.sorted <- counts1[order(rowMeans(counts1[,zero5.inx])),]
  }
  counts.sorted.rev <- apply(counts.sorted,2,rev)
  } else {
  counts1 <- (counts[[bamNames[clusterSample]]])
  dist_mat <- dist(counts1, method = 'euclidean')
  hclust_avg <- hclust(dist_mat, method = 'average')
  }

#initialize empty heatmap list
ht_list = NULL
#generate bottom annotation with binnames
if(max(abs(as.numeric(colnames(counts1)))) > 1000){
binnames <- ifelse((as.numeric(colnames(counts1))/1000)%%1==0,colnames(counts1),"")
} else {
binnames <- ifelse((as.numeric(colnames(counts1))/100)%%1==0,colnames(counts1),"")
}
bin_anno <- HeatmapAnnotation(text = anno_text(binnames, rot = 45, location = unit(1, "npc"), just = "right",gp=gpar(fontsize=8,fontface = "italic")),
                              annotation_height = max_text_width(binnames))

#take log2 of all counts tables (adding a pseudocount of 1 if 0s are present in the table)
all.counts.log <- lapply(counts,Log2Transform,pseudocount =1)

#summarize the counts per bin for the cumulative plot
all.counts.median <- lapply(all.counts.log, function(x) apply(x,2,summarizing))
all.counts.max <- max(unlist(all.counts.median))

#loop over all samples
for (bam.sample in seq_along(bamNames)){

  #select counts table for current sample
  counts.median <- (all.counts.median[[bamNames[bam.sample]]])

  #select the y-axis limits of the metaplots:
  #a) maximum is the maximum of all counts tables,
  #b) maximum is the maximum of each counts table
  if (MetaScale[bam.sample] == "all"){
    anno.lims <- c(0,all.counts.max)
  } else {
    anno.lims <- c(0,max(0.1,max(counts.median)))
}
  #generate cumulative plot as heatmap annotation
  cumulative_anno <- HeatmapAnnotation(x=anno_lines(counts.median,size=unit(1, "mm"),axis=show_axis,smooth=FALSE,
                                 border=FALSE, ylim=anno.lims,
                                 gp=gpar(lwd=2,col=plotcols[bam.sample])),show_annotation_name=FALSE)

  #select log transformed or original count values based on use.log option
  if(use.log == TRUE){
    counts3 <- (all.counts.log[[bamNames[bam.sample]]])
  } else {
    counts3 <- (counts[[bamNames[bam.sample]]])
  }

  #generate plotting color cutoffs based on cutoffs provided or min,median,max
  if (missing(bottomCpm)){
    BottomCpm <- min(counts3)
  } else {
    BottomCpm <- bottomCpm[bam.sample]
  }
  if (missing(medianCpm)){
    MedianCpm <- median(counts3)
  } else {
    MedianCpm <- medianCpm[bam.sample]
  }
  if (missing(topCpm)){
    TopCpm <- max(counts3)
  } else {
    TopCpm <- topCpm[bam.sample]
  }

  if(BottomCpm == TopCpm){
    sprintf("bottomCpm = topCpm for sample %s : please provide different values",bamNames[bam.sample])
    next
  } else {
  plotcolor <- circlize::colorRamp2(c(BottomCpm, MedianCpm, TopCpm), c("white", plotcols[bam.sample],"black"))
}

#decide if bin 0 value ordering or clustering is used
  if(orderSample > 0){

    #order the rows of the current counts table by the middle-value-sorted sample counts table
    counts.sorted <- counts3[row.names(counts.sorted.rev),]

    if (TargetHeight > 0){
    #summarize the rows to make the heatmap look smoother
    counts.sorted <- redim_matrix(counts.sorted, target_height = TargetHeight, target_width = ncol(counts.sorted))
    }

    #split the heatmap into 2 parts (only works if the counts.sorted table was not summarized)
    if(missing(splitHM)){
      row_split = NULL
    } else {
      row_split = ifelse(row.names(counts.sorted) %in% splitHM,split_pos,split_neg)
    }

#generate the heatmap list entry for the current sample (sorted by the middle values of the specified sample (orderSample option)) and append to complete heatmap list
  ht_list <- ht_list + Heatmap(counts.sorted,name = bamNames[bam.sample], cluster_rows = FALSE, cluster_columns = FALSE,
                               column_order = colnames(counts.sorted), col = plotcolor,
                               column_title = bamNames[bam.sample], column_title_gp = gpar(fontsize = 10, fontface = "bold"),
                               show_row_names = FALSE, show_column_names = FALSE,
                               bottom_annotation = bin_anno,
                               top_annotation = cumulative_anno,
                               use_raster = TRUE, raster_device = "CairoPNG",raster_quality=1,
                               #use_raster = TRUE, raster_device = "png",raster_quality=1,
                               row_split = row_split
   )
  } else {

    #split the heatmap into 2 parts
    if(missing(splitHM)){
      row_split = NULL
    } else {
      row_split = ifelse(row.names(counts3) %in% splitHM,split_pos,split_neg)
    }

    #generate the heatmap list entry for the current sample (sorted by the clustering of the specified sample (clusterSample option)) and append to complete heatmap list
    ht_list <- ht_list + Heatmap(counts3,name = bamNames[bam.sample], cluster_rows = hclust_avg, cluster_columns = FALSE,
                                 column_order = colnames(counts3), col = plotcolor,
                                 column_title = bamNames[bam.sample], column_title_gp = gpar(fontsize = 10, fontface = "bold"),
                                 show_row_names = FALSE, show_column_names = FALSE,
                                 bottom_annotation = bin_anno,
                                 top_annotation = cumulative_anno,
                                 use_raster = TRUE, raster_device = "CairoPNG",raster_quality=1,
                                # use_raster = UseRaster, raster_device = "png",raster_quality=1,
                                 row_split = row_split, show_row_dend = FALSE,show_column_dend = FALSE,
    )
  }}
return(ht_list)
}
