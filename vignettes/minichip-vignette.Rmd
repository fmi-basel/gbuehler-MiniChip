---
title: "Vignette for MiniChip package"
author: "Michaela Schwaiger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette for MiniChip package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this vignette for the MiniChip package we will generate a GRanges object of ChIP-seq peaks for Adnp2, as well as a matched Granges object of randomized peaks across the mouse genome. Then we will plot the distribution of Adnp2 read counts (per Million reads) across the peak summits. 

```{r}
library(MiniChip)
```

## Generate a peaks GRanges object.

First we load the narrowPeak output files generated by MACS peak finding for all 3 Adnp2 ChIP replicates, name the culumns in a meaningful way, and turn them into GRanges objects.

```{r}
peaks1.d <- read.table("/tungstenfs/scratch/gbuehler/michi/Projects/Adnp2/Adnp2_Chipseq/Adnp2_ChIP_2ndtry/Adnp2_clone71_CHIP_withUntagged_extsize160_peaks.narrowPeak",header=F)
peaks2.d <- read.table("/tungstenfs/scratch/gbuehler/michi/Projects/Adnp2/Adnp2_Chipseq/Adnp2_ChIP_2ndtry/Adnp2_clone85_CHIP_withUntagged_extsize160_peaks.narrowPeak",header=F)
peaks3.d <- read.table("/tungstenfs/scratch/gbuehler/michi/Projects/Adnp2/Adnp2_Chipseq/Adnp2_ChIP_2ndtry/Adnp2_clone92_CHIP_withUntagged_peaks.narrowPeak",header=F)

names(peaks1.d) <- c("chr","start","end","name","score","empty","foldchange","pvalue","qvalue","summit")
names(peaks2.d) <- c("chr","start","end","name","score","empty","foldchange","pvalue","qvalue","summit")
names(peaks3.d) <- c("chr","start","end","name","score","empty","foldchange","pvalue","qvalue","summit")

peaks1 <- makeGRangesFromDataFrame(peaks1.d,
                                   keep.extra.columns=TRUE,
                                   ignore.strand=TRUE,
                                   seqinfo=NULL,
                                   seqnames.field=c("chr"),
                                   start.field=c("start"),
                                   end.field=c("end"),
                                   starts.in.df.are.0based=FALSE)

peaks2 <- makeGRangesFromDataFrame(peaks2.d,
                                   keep.extra.columns=TRUE,
                                   ignore.strand=TRUE,
                                   seqinfo=NULL,
                                   seqnames.field=c("chr"),
                                   start.field=c("start"),
                                   end.field=c("end"),
                                   starts.in.df.are.0based=FALSE)

peaks3 <- makeGRangesFromDataFrame(peaks3.d,
                                   keep.extra.columns=TRUE,
                                   ignore.strand=TRUE,
                                   seqinfo=NULL,
                                   seqnames.field=c("chr"),
                                   start.field=c("start"),
                                   end.field=c("end"),
                                   starts.in.df.are.0based=FALSE)
```

Then we select only the peaks which occur in at least 2 of the 3 replicates using the GRanges subsetByOverlaps and overlapsAny functions.

```{r}
# peaks that occur in at least 2/3 replicates
peaks3.1 <- subsetByOverlaps(peaks3,peaks1)
peaks3.2 <- subsetByOverlaps(peaks3,peaks2)
peaks1.2 <- subsetByOverlaps(peaks1,peaks2)

#keep all 3.1 peaks, find 3.2 and 1.2 peaks that do not overlap 3.1 peaks

# peaks which are found in 3 and 2, but not in 3 and 1, and not in 1 and 2
peaks3.2u <- peaks3.2[overlapsAny(peaks3.2,peaks3.1) ==FALSE & overlapsAny(peaks3.2,peaks1.2) == FALSE]
# peaks which are found in 1 and 2, but not in 3 and 1, and not in 3 and 2
peaks1.2u <- peaks1.2[overlapsAny(peaks1.2,peaks3.1) ==FALSE & overlapsAny(peaks1.2,peaks3.2) == FALSE]
# add together all 3.1 peaks as well as unique 3.2 and 1.2 peaks
peaks <- c(peaks3.1,peaks3.2u,peaks1.2u)
```

We can now generate a peaknames object describing the peaks GRanges object we have just selected (for later use), and look at the peaks GRanges object to make sure it countains seqnames (chromosomes), start, end, strand, summit, and name filedds, as required by many functions in the MiniChip package.

```{r}
peaknames <- "Adnp2_peaks_in2of3replicates_2ndtry"
peaks
```

## Generate a randomly shuffled peaks GRanges object.

Then we use the SimulatePeaks function from the MiniChip package to generate a GRanges object called random.peaks that contains the same number of peaks (of the same lengths) as the original peaks GRanges object, but ech one shuffled to a randomly chosen location in the mouse genome. This is a useful control object to have when comparing the overlap of ChIP peaks with genomic annotations, for example genes or repeat elements. 

```{r}
#  randomize peak locations
nSites <- length(peaks)
peak.widths <- width(peaks)
random.peaks <-  SimulatePeaks(nSites,peak.widths)
```

## Draw heatmaps of Adnp2 ChIP-seq read counts across the peak summits (+/- 3025bp).

First, we select the bam files of mapped reads that we want to use from the gbuehler deepSeqRepos....

```{r}
#select bam files from Adnp2 experiment
all.bamFiles <- list.files("/work2/gbuehler/deepSeqRepos/bam/", full.names=TRUE,pattern="*bam$")
bamFiles <- grep("1950F",all.bamFiles,value=TRUE)[1:8]
bamFiles
```

...and extract short but meaningful names for the bam files decribing what has been chipped. 

```{r}
bamNames <- gsub("/work2/gbuehler/deepSeqRepos/bam//","",bamFiles)
bamNames <- gsub(".bam","",bamNames)
bamNames
```

You can select any bamFile that you are interested in, and the number of bamFiles you can choose is unlimited. However, please do not use all bam files in the repository (the all.bamFiles in the example above)!

Now we define the span (distance from peak summit to left and right, in this case 3025bp), and step size for windows across the peaks (in this case 50bp).Then we use the SummitHeatmap function for the MiniChip package to calculate the counts per million (cpm) reads of each bam file in each window across the summit of each peak in the peaks object.

```{r}
span <- 3025
step <- 50
counts <- SummitHeatmap(peaks,peaknames,bamFiles,bamNames,span,step,plotHM=FALSE,useCPM=TRUE)
```

This will return the counts object, a list of length 8 (since we are using 8 bam files), where each element of the list contains a  matrix of cpm values across all windows for all peaks. If you want to also save a seperately clustered heatmap for each bam file to a file, set plotHM=TRUE. 

To plot heatmaps for each sample (bam file) sorted by the first bam file, you can use the DrawSummitHeatmaps function. By providing shorter names for the samples you can ensure nice heatmap titles. Here we select only the ChIP samples (and not the Input samples).

```{r expression_example, fig.width = 10, fig.height = 8}
library(ComplexHeatmap)
nicebamNames <- c("Adnp2","Input","Adnp2","Input","Adnp2","Input","Untagged_Input","Untagged")
ht_list <- DrawSummitHeatmaps(counts[c(1,3,5)], bamNames[c(1,3,5)], nicebamNames[c(1,3,5)])
draw(ht_list, padding = unit(c(3, 8, 8, 2), "mm"))
```


